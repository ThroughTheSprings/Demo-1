<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>CSS451 Final Project: Through the springs</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <script src="js/three.js"></script>

    <script src="js/dat.gui.js"></script>
    <script src="js/Mirror.js"></script>
    <script src="js/WaterShader.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script src="js/loaders/MTLLoader.js"></script>
    <script src="js/loaders/OBJLoader.js"></script>

    <script>
        // initialize scene, camera, and renderer
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(55, window.innerWidth /
        window.innerHeight, 0.5, 3000000);
        camera.position.set(40, 40, 40);

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0xdddddd);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //controls.enablePan = false;
        //controls.minDistance = 40.0;
        //controls.maxDistance = 100.0;

        // adds helpers
        var axis = new THREE.AxisHelper(10);
        //scene.add(axis);

        var grid = new THREE.GridHelper(50, 10);
        var color = new THREE.Color("rgb(255,0,0)");
        grid.setColors(color, 0x000000);
        //scene.add(grid);

        // add lights
        var light = new THREE.DirectionalLight(0xffffbb, 1);
        light.position.set(1, 1, 1);
        scene.add(light);

        scene.add(new THREE.AmbientLight(0x444444));

        // load skybox
        var urls = [
            'textures/Meadow/posx.jpg',
            'textures/Meadow/negx.jpg',
            'textures/Meadow/posy.jpg',
            'textures/Meadow/negy.jpg',
            'textures/Meadow/posz.jpg',
            'textures/Meadow/negz.jpg',
        ];

        var loader = new THREE.CubeTextureLoader();
        var cubeMap = loader.load(urls);        // load textures
        cubeMap.format = THREE.RGBFormat;

        var cubeShader = THREE.ShaderLib['cube'];  // init cube shader from built-in lib
        cubeShader.uniforms['tCube'].value = cubeMap; // apply textures to shader

        // create shader material
        var skyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader: cubeShader.fragmentShader,
            vertexShader: cubeShader.vertexShader,
            uniforms: cubeShader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
        });

        // create skybox mesh
        var skyBox = new THREE.Mesh(
            new THREE.BoxGeometry(1000000, 1000000, 1000000),
            skyBoxMaterial
        );

        scene.add(skyBox);


        // add plane
        var texture = new THREE.TextureLoader().load("textures/stonetexture.jpg");
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2, 2);

        var planeGeometry = new THREE.PlaneGeometry(150, 150, 150);
        var planeMaterial = new THREE.MeshPhongMaterial({ //color: 0xffffff 
            map: texture,
        });
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);

        plane.rotation.x = -0.5 * Math.PI;
        scene.add(plane);

        // add rectangles
        var stoneTexture = new THREE.TextureLoader().load("textures/stonetexture3.jpg");
        stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;
        stoneTexture.repeat.set(1, 3);

        // first
        var negxRectGeo = new THREE.BoxGeometry(5, 125, 25);
        var negxRectMat = new THREE.MeshPhongMaterial({ //color: 0xddffdd
            map: stoneTexture, //envMap: cubeMap,
        });

        var negxRect = new THREE.Mesh(negxRectGeo, negxRectMat);
        negxRect.rotation.x = -0.5 * Math.PI;
        negxRect.position.set(-50, 12.5, 10);
        scene.add(negxRect);

        // second
        var cubeCamera = new THREE.CubeCamera(1, 1000000, 1024);
        scene.add(cubeCamera);

        var ceramicTexture = new THREE.TextureLoader().load("textures/ceramictexture1.jpg");
        ceramicTexture.wrapS = ceramicTexture.wrapT = THREE.RepeatWrapping;
        ceramicTexture.repeat.set(1, 4);

        var negxRectGeo1 = new THREE.BoxGeometry(23.5, 120, 5);
        var negxRectMat1 = new THREE.MeshPhongMaterial({ //color: 0xddffdd
            map: ceramicTexture, envMap: cubeCamera.renderTarget,
            reflectivity: 0.3,
        });

        var negxRect1 = new THREE.Mesh(negxRectGeo1, negxRectMat1);
        negxRect1.rotation.x = -0.5 * Math.PI;
        negxRect1.position.set(-37, 2.5, 10);
        scene.add(negxRect1);

        // third
        var stoneTexture1 = new THREE.TextureLoader().load("textures/stonetexture3.jpg");
        stoneTexture1.wrapS = stoneTexture1.wrapT = THREE.RepeatWrapping;
        stoneTexture1.repeat.set(3, 1);
        var negzRectGeo = new THREE.BoxGeometry(120, 5, 25);
        var negzRectMat = new THREE.MeshPhongMaterial({ //color: 0xddffdd 
            map: stoneTexture1, //envMap: cubeMap,
        });
        var negzRect = new THREE.Mesh(negzRectGeo, negzRectMat);
        negzRect.rotation.x = -0.5 * Math.PI;
        negzRect.position.set(12.5, 12.5, -50);
        scene.add(negzRect);

        // fourth
        var soilTexture = new THREE.TextureLoader().load("textures/soilTexture.jpg");
        soilTexture.wrapS = soilTexture.wrapT = THREE.RepeatWrapping;
        soilTexture.repeat.set(1, 4);
        var posxRectGeo = new THREE.BoxGeometry(18, 120, 5);
        var posxRectMat = new THREE.MeshPhongMaterial({ //color: 0xddffdd 
            map: soilTexture, //envMap: cubeMap,
        });
        var posxRect = new THREE.Mesh(posxRectGeo, posxRectMat);
        posxRect.rotation.x = -0.5 * Math.PI;
        posxRect.position.set(57.5, 2.5, 10);
        scene.add(posxRect);

        // add water
        waterNormals = new THREE.TextureLoader().load('textures/waternormals2.jpg');
        waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

        water = new THREE.Water(renderer, camera, scene, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: waterNormals,
            alpha: 0.8,
            sunDirection: light.position.clone().normalize(),
            sunColor: 0xffffff,
            waterColor: 0x87CEFA,
            //waterColor: 0x001e0f,
            distortionScale: 5.0,
        });

        mirrorMesh = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(75, 120),
                water.material
        );

        mirrorMesh.add(water);
        mirrorMesh.rotation.x = -Math.PI * 0.5;
        mirrorMesh.position.set(12.5, 2, 10);
        scene.add(mirrorMesh);

        // Init MLT and OBJ loader 
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setBaseUrl('obj/tree3/');
        mtlLoader.setPath('obj/tree3/');

        // add model trees
        mtlLoader.load('Birch004_Autumn.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('obj/tree3/');
            
            // first tree
            objLoader.load('Birch004_Autumn.obj', function (tree) {
                tree.children[0].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Bark-Texture.jpg')
                });
                tree.children[1].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg')
                });
                tree.children[2].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg')
                });
                tree.children[3].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Barksmall-Texture.jpg')
                });
                tree.children[4].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg'),
                });
                tree.children[5].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Bark-Texture_large.jpg')
                });
                tree.scale.x = tree.scale.y = tree.scale.z = 0.03;
                tree.rotation.y -= Math.PI / 3;
                tree.position.set(60, 5, 30);
                tree.remove(tree.children[1]);
                scene.add(tree);
            });

            // second tree
            objLoader.load('Birch004_Autumn.obj', function (tree1) {
                tree1.children[0].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Bark-Texture.jpg')
                });
                tree1.children[1].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg')
                });
                tree1.children[2].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg')
                });
                tree1.children[3].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Barksmall-Texture.jpg')
                });
                tree1.children[4].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/birch_leaf_summer_1.jpg')
                });
                tree1.children[5].material = new THREE.MeshPhongMaterial({
                    map:
                        new THREE.TextureLoader().load('obj/tree3/Birch-Bark-Texture_large.jpg')
                });
                tree1.scale.x = tree1.scale.y = tree1.scale.z = 0.04;
                tree1.rotation.y -= Math.PI / 2;
                tree1.position.set(60, 5, 0);
                scene.add(tree1);

            }/*, onProgress, onError*/);
        });

        // add model rocks
        mtlLoader.setBaseUrl('obj/rocks1/');
        mtlLoader.setPath('obj/rocks1/');
        mtlLoader.load('rocks_01_model.mtl', function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('obj/rocks1/');
            objLoader.load('rocks_01_model.obj', function (rock1) {                               
                rock1.children[0].position.set(80, 0, -300);
                rock1.children[1].rotation.x += Math.PI / 2;
                rock1.children[1].rotation.z -= Math.PI / 4;
                rock1.children[1].scale.set(1.5, 1.0, 1.5);
                rock1.children[1].position.set(100, 150, 300);
                rock1.children[2].position.set(-20, 0, 0);
                rock1.children[3].scale.y = 0.5;
                rock1.children[3].rotation.x += Math.PI / 2;
                rock1.children[3].rotation.z += Math.PI / 2;
                rock1.children[3].position.set(200, 0, 500);
                rock1.children[4].position.set(0, 0, 330);
                rock1.position.set(40, 0, 0);
                rock1.scale.x = rock1.scale.y = rock1.scale.z = 0.05;
                scene.add(rock1);
            });

        });
        

        function animate() {

            requestAnimationFrame(animate);
            render();
            renderer.render(scene, camera);
        }

        function render() {
            // var time = performance.now() * 0.001;

            water.material.uniforms.time.value += 1.0 / 100.0;
            controls.update();
            water.render();

            ////Update the render target cube
            negxRect1.visible = false;
            cubeCamera.position.copy(negxRect1.position);
            cubeCamera.updateCubeMap(renderer, scene);
            negxRect1.visible = true;
            
        }
        animate();
    </script>
</body>
</html>
